import { 
  ToolType, 
  ExecutionContext, 
  ExecutionResult 
} from "../../models/agent-model";
import { BaseSimpleTool, ToolParameter, DetailedToolInfo } from "../base-tool";

/**
 * Worldbook Tool - Pure Execution Unit
 * Handles worldbook generation metadata based on provided parameters from planner
 * Actual content generation is handled by AgentEngine
 */
export class WorldbookTool extends BaseSimpleTool {
  readonly toolType = ToolType.WORLDBOOK;
  readonly name = "WORLDBOOK";
  readonly description = "Process a pre-generated worldbook entry and validate its structure";
  
  readonly parameters: ToolParameter[] = [
    {
      name: "worldbook_entry",
      type: "object",
      description: "A single, complete worldbook entry generated by the planner. The entry must contain id, uid, key, content, and other worldbook fields.",
      required: true,
      properties: {
        id: { type: "string", description: "Unique identifier for the entry" },
        uid: { type: "string", description: "Numeric ID as string (e.g., '1001')" },
        key: { type: "array", description: "Array of primary trigger keywords" },
        keysecondary: { type: "array", description: "Array of secondary trigger keywords", required: false },
        comment: { type: "string", description: "Brief description of what this entry covers" },
        content: { type: "string", description: "Detailed worldbook content that enhances roleplay" },
        constant: { type: "boolean", description: "Whether entry is always active", required: false, default: false },
        selective: { type: "boolean", description: "Whether entry uses selective activation", required: false, default: true },
        order: { type: "number", description: "Display/processing order", required: false, default: 100 },
        position: { type: "number", description: "Position in worldbook", required: false, default: 0 },
        disable: { type: "boolean", description: "Whether entry is disabled", required: false, default: false },
        probability: { type: "number", description: "Activation probability (0-100)", required: false, default: 100 },
        useProbability: { type: "boolean", description: "Whether to use probability activation", required: false, default: true }
      }
    }
  ];

  getToolInfo(): DetailedToolInfo {
    return {
      type: ToolType.WORLDBOOK,
      name: this.name,
      description: this.description,
      parameters: this.parameters
    };
  }

  protected async doWork(parameters: Record<string, any>, context: ExecutionContext): Promise<any> {
    const worldbookEntry = parameters.worldbook_entry;
    
    console.log(`ðŸ“š Worldbook tool processing a single pre-generated entry`);

    if (!worldbookEntry || typeof worldbookEntry !== 'object') {
      throw new Error("No worldbook entry object provided by planner");
    }

    // Validate and fix entry structure
    const validatedEntry = {
      id: worldbookEntry.id || `wb_entry_${Date.now()}`,
      uid: worldbookEntry.uid || (1000).toString(),
      key: Array.isArray(worldbookEntry.key) ? worldbookEntry.key : [worldbookEntry.key || "keyword"],
      keysecondary: Array.isArray(worldbookEntry.keysecondary) ? worldbookEntry.keysecondary : [],
      comment: worldbookEntry.comment || "Worldbook entry",
      content: worldbookEntry.content || "Content not generated",
      constant: worldbookEntry.constant || false,
      selective: worldbookEntry.selective !== false,
      order: worldbookEntry.order || 100,
      position: worldbookEntry.position || 0,
      disable: worldbookEntry.disable || false,
      probability: worldbookEntry.probability || 100,
      useProbability: worldbookEntry.useProbability !== false
    };

    // Calculate quality metrics based on the generated entry
    const qualityMetrics = this.calculateWorldbookQuality([validatedEntry], context);

    console.log(`âœ… Worldbook data processed - 1 entry, Quality: ${Math.round(qualityMetrics.overall_quality)}%`);

    return {
      entry_count: 1,
      worldbook_data: [validatedEntry], // Return as array for consistent state updates
      quality_metrics: qualityMetrics,
      GenerationOutputUpdate: {
        worldbook_data: [validatedEntry], // Keep it as an array in the state
        quality_metrics: {
          completeness: qualityMetrics.overall_quality,
          consistency: qualityMetrics.consistency,
          creativity: qualityMetrics.creativity,
          user_satisfaction: context.research_state.progress.user_satisfaction
        }
      }
    };
  }

  /**
   * Calculate worldbook quality metrics based on generated entries
   */
  private calculateWorldbookQuality(entries: any[], context: ExecutionContext): any {
    const metrics = {
      coverage: 0,
      keyword_quality: 0,
      content_richness: 0,
      consistency: 0,
      overall_quality: 0
    };

    if (!entries || entries.length === 0) {
      return metrics;
    }

    // Coverage: Based on number and variety of entries (now always 1)
    metrics.coverage = 20; // Single entry gives low coverage score

    // Keyword quality: Check if keywords are well-formed
    const totalKeywords = entries.reduce((sum, entry) => 
      sum + (entry.key ? entry.key.length : 0), 0
    );
    const avgKeywords = totalKeywords / entries.length;
    metrics.keyword_quality = Math.min(avgKeywords * 25, 100); // 3-4 keywords per entry ideal

    // Content richness: Based on content length and detail
    const avgContentLength = entries.reduce((sum, entry) => 
      sum + (entry.content ? entry.content.length : 0), 0
    ) / entries.length;
    metrics.content_richness = Math.min((avgContentLength / 300) * 100, 100); // 300 chars ideal

    // Consistency: Based on available knowledge and character alignment
    const hasVariety = new Set(entries.map(e => e.comment.split(' ')[0])).size > 1;
    metrics.consistency = hasVariety ? 80 : 60;

    // Overall quality
    metrics.overall_quality = (
      metrics.coverage * 0.25 + 
      metrics.keyword_quality * 0.25 + 
      metrics.content_richness * 0.3 + 
      metrics.consistency * 0.2
    );

    return { ...metrics, creativity: metrics.content_richness };
  }
} 