import { v4 as uuidv4 } from "uuid";
import { BaseTool } from "../base-tool";
import { ToolType, ToolExecutionContext, ToolExecutionResult, PlanTask } from "../../models/agent-model";
import { ResultOperations } from "../../data/agent/result-operations";
import { OutputPrompts } from "./prompts";

/**
 * Output Tool - Generate character and worldbook content
 */
export class OutputTool extends BaseTool {
  readonly toolType = ToolType.OUTPUT;
  readonly name = "Content Generator";
  readonly description = "Generate character data and worldbook entries";

  async executeToolLogic(task: PlanTask, context: ToolExecutionContext): Promise<ToolExecutionResult> {
    const type = task.parameters.type;
    
    if (type === "character") {
      return await this.generateCharacter(task, context);
    } else if (type === "worldbook") {
      return await this.generateWorldbook(task, context);
    }

    throw new Error("Unknown output type - expected 'character' or 'worldbook'");
  }

  private async generateCharacter(task: PlanTask, context: ToolExecutionContext): Promise<ToolExecutionResult> {
    const prompt = await this.createContextualPrompt(
      OutputPrompts.getCharacterGenerationSystemPrompt(),
      OutputPrompts.getCharacterGenerationHumanTemplate(),
      task,
      context
    );

    const characterData = await this.executeLLMChain(prompt, {}, context, {
      parseJson: true,
      errorMessage: "Failed to generate character data"
    });
    
    // Ensure required fields exist
    const completeCharacterData = {
      name: characterData.name || "Generated Character",
      description: characterData.description || "",
      personality: characterData.personality || "",
      scenario: characterData.scenario || "",
      first_mes: characterData.first_mes || `Hello, I'm ${characterData.name || "your character"}.`,
      mes_example: characterData.mes_example || "",
      creator_notes: characterData.creator_notes || "Generated by AI Agent",
      avatar: "",
      alternate_greetings: characterData.alternate_greetings || [],
      tags: characterData.tags || [],
    };
    
    await ResultOperations.updateCharacterData(context.conversation_id, completeCharacterData);
    
    await this.addMessage(
      context.conversation_id,
      "agent",
      `✅ Generated character: **${completeCharacterData.name}**\n\n${completeCharacterData.description.substring(0, 200)}...`,
    );
    
    return this.createSuccessResult(completeCharacterData, {
      reasoning: `Successfully generated character: ${completeCharacterData.name}`
    });
  }

  private async generateWorldbook(task: PlanTask, context: ToolExecutionContext): Promise<ToolExecutionResult> {
    const prompt = await this.createContextualPrompt(
      OutputPrompts.getWorldbookGenerationSystemPrompt(),
      OutputPrompts.getWorldbookGenerationHumanTemplate(),
      task,
      context
    );

    const worldbookEntries = await this.executeLLMChain(prompt, {}, context, {
      parseJson: true,
      errorMessage: "Failed to generate worldbook entries"
    });
    
    // Format entries properly
    const formattedEntries = worldbookEntries.map((entry: any, index: number) => ({
      id: uuidv4(),
      uid: uuidv4(),
      key: Array.isArray(entry.key) ? entry.key : [entry.key],
      keysecondary: entry.keysecondary || [],
      comment: entry.comment || `Entry ${index + 1}`,
      content: entry.content || "",
      constant: entry.constant || false,
      selective: entry.selective !== false, // Default to true
      order: index,
      position: entry.position || 0,
      disable: false,
      probability: entry.probability || 100,
      useProbability: entry.useProbability || false,
    }));
    
    await ResultOperations.updateWorldbookData(context.conversation_id, formattedEntries);
    
    await this.addMessage(
      context.conversation_id,
      "agent",
      `✅ Generated ${formattedEntries.length} worldbook entries:\n${formattedEntries.map((e: any) => `• ${e.comment}`).join("\n")}`,
    );
    
    return this.createSuccessResult(formattedEntries, {
      reasoning: `Successfully generated ${formattedEntries.length} worldbook entries`
    });
  }
} 