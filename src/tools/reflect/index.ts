import { 
  ToolType, 
  ExecutionContext, 
  ExecutionResult,
  TaskEntry
} from "../../models/agent-model";
import { BaseSimpleTool, ToolParameter, DetailedToolInfo } from "../base-tool";

/**
 * Reflect Tool - Pure Execution Unit
 * Adds new tasks with sub-problems to the task queue based on provided parameters from planner
 */
export class ReflectTool extends BaseSimpleTool {
  
  readonly toolType = ToolType.REFLECT;
  readonly name = "REFLECT";
  readonly description = "Add new tasks with sub-problems to the task queue based on analysis of current progress and needs. Use when you identify gaps in the current task plan, need to break down complex work into smaller steps, or when new requirements emerge during generation. IMPORTANTLY: Also use this tool when the task queue is empty but the main objective is not yet complete - analyze what still needs to be done and generate the necessary tasks to finish the work. This tool helps maintain organized task flow and ensures comprehensive character and worldbook development.";
  
  readonly parameters: ToolParameter[] = [
    {
      name: "new_tasks",
      type: "array",
      description: "Array of new task objects with sub-problems. Each task should have: description (string), reasoning (string), and sub_problems (array of {description, reasoning}). Use CDATA format when passing JSON in XML: <![CDATA[...]]>",
      required: true
    }
  ];

  getToolInfo(): DetailedToolInfo {
    return {
      type: ToolType.REFLECT,
      name: this.name,
      description: this.description,
      parameters: this.parameters
    };
  }

  protected async doWork(parameters: Record<string, any>, context: ExecutionContext): Promise<ExecutionResult> {
    const newTasksParam = parameters.new_tasks;
    
    if (!newTasksParam || !Array.isArray(newTasksParam)) {
      return this.createFailureResult("REFLECT tool requires 'new_tasks' parameter as an array.");
    }
    
    if (newTasksParam.length === 0) {
      return this.createFailureResult("REFLECT tool requires at least one task in 'new_tasks' array.");
    }
    
    // Convert and validate task structure
    const newTasks: TaskEntry[] = [];
    for (let i = 0; i < newTasksParam.length; i++) {
      const taskData = newTasksParam[i];
      
      if (!taskData || typeof taskData !== 'object') {
        return this.createFailureResult(`REFLECT tool: Task ${i + 1} must be an object.`);
      }
      
      if (!taskData.description || typeof taskData.description !== 'string') {
        return this.createFailureResult(`REFLECT tool: Task ${i + 1} must have a valid 'description' string.`);
      }
      
      if (!taskData.sub_problems || !Array.isArray(taskData.sub_problems)) {
        return this.createFailureResult(`REFLECT tool: Task ${i + 1} must have 'sub_problems' as an array.`);
      }
      
      // Validate sub-problems
      const subProblems = [];
      for (let j = 0; j < taskData.sub_problems.length; j++) {
        const subProblem = taskData.sub_problems[j];
        if (!subProblem.description || typeof subProblem.description !== 'string') {
          return this.createFailureResult(`REFLECT tool: Task ${i + 1}, sub-problem ${j + 1} must have a valid 'description' string.`);
        }
        
        subProblems.push({
          id: `reflect_sub_${Date.now()}_${i}_${j}`,
          description: subProblem.description,
          reasoning: subProblem.reasoning || "Generated by reflection"
        });
      }
      
      newTasks.push({
        id: `reflect_task_${Date.now()}_${i}`,
        description: taskData.description,
        reasoning: taskData.reasoning || "Generated by reflection",
        sub_problems: subProblems
      });
    }

    return this.createSuccessResult({
      new_tasks: newTasks,
      tasks_count: newTasks.length
    });
  }
} 